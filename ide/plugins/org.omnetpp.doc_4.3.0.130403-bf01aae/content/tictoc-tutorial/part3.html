<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Tictoc Tutorial: 3. Turning it into a real network</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="part3">3. Turning it into a real network </a></h1>PREV: <a class="el" href="part2.html">2. Enhancing the 2-node TicToc</a> UP: <a class="el" href="index.html#contents">Contents</a><h2><a class="anchor" name="s10">
Step 10: More than two nodes</a></h2>
Now we'll make a big step: create several tic modules and connect them into a network. For now, we'll keep it simple what they do: one of the nodes generates a message, and the others keep tossing it around in random directions until it arrives at a predetermined destination node.<p>
The NED file will need a few changes. First of all, the Txc module will need to have multiple input and output gates:<p>
 <div class="fragment"><pre class="fragment">simple <a class="code" href="classTxc10.html">Txc10</a>
{
    parameters:
        @display(<span class="stringliteral">"i=block/routing"</span>);
    gates:
        input in[];  <span class="comment">// declare in[] and out[] to be vector gates</span>
        output out[];
}
</pre></div><p>
The [ ] turns the gates into gate vectors. The size of the vector (the number of gates) will be determined where we use Txc to build the network.<p>
<div class="fragment"><pre class="fragment">network Tictoc10
{
    submodules:
        tic[6]: <a class="code" href="classTxc10.html">Txc10</a>;
    connections:
        tic[0].out++ --&gt; {  delay = 100ms; } --&gt; tic[1].in++;
        tic[0].in++ &lt;-- {  delay = 100ms; } &lt;-- tic[1].out++;

        tic[1].out++ --&gt; {  delay = 100ms; } --&gt; tic[2].in++;
        tic[1].in++ &lt;-- {  delay = 100ms; } &lt;-- tic[2].out++;

        tic[1].out++ --&gt; {  delay = 100ms; } --&gt; tic[4].in++;
        tic[1].in++ &lt;-- {  delay = 100ms; } &lt;-- tic[4].out++;

        tic[3].out++ --&gt; {  delay = 100ms; } --&gt; tic[4].in++;
        tic[3].in++ &lt;-- {  delay = 100ms; } &lt;-- tic[4].out++;

        tic[4].out++ --&gt; {  delay = 100ms; } --&gt; tic[5].in++;
        tic[4].in++ &lt;-- {  delay = 100ms; } &lt;-- tic[5].out++;
}
</pre></div><p>
Here we created 6 modules as a module vector, and connected them.<p>
The resulting topology looks like this:<p>
<div align="center">
<img src="step10.png" alt="step10.png">
</div>
<p>
In this version, tic[0] will generate the message to be sent around. This is done in initialize(), with the help of the getIndex() function which returns the index of the module in the vector.<p>
The meat of the code is the forwardMessage() function which we invoke from handleMessage() whenever a message arrives at the node. It draws a random gate number (size() is the size of the gate vector), and sends out message on that gate.<p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="classTxc10.html#c0a6e2b462a2615f6c0ce388ceec62a4">Txc10::forwardMessage</a>(<a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> *msg)
{
    <span class="comment">// In this example, we just pick a random gate to send it on.</span>
    <span class="comment">// We draw a random number between 0 and the size of gate `out[]'.</span>
    <span class="keywordtype">int</span> n = <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcModule.html#c63b0b9c805c5f335d274195f2fdb28c">gateSize</a>(<span class="stringliteral">"out"</span>);
    <span class="keywordtype">int</span> k = <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//group__RandomNumbersDiscr.html#gee8ce6ae7e43b06e968a023f25c91b4f">intuniform</a>(0,n-1);

    <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//group__Envir.html#g650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">"Forwarding message "</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">" on port out["</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">"]\n"</span>;
    <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcSimpleModule.html#94590ba6481116f29f4c43d00733deea">send</a>(msg, <span class="stringliteral">"out"</span>, k);
}
</pre></div><p>
When the message arrives at tic[3], its handleMessage() will delete the message.<p>
See the full code in <a class="el" href="txc10.cc.html">txc10.cc</a>.<p>
<em>Exercise: you'll notice that this simple "routing" is not very efficient: often the packet keeps bouncing between two nodes for a while before it is sent to a different direction. This can be improved somewhat if nodes don't send the packet back to the sender. Implement this. Hints: <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html#1aeaf09baf5a3584c17cd64edccc1037">cMessage::getArrivalGate()</a>, <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcGate.html#0ec58c0c39b875a03cfc18bd20059d3b">cGate::getIndex()</a>. Note that if the message didn't arrive via a gate but was a self-message, then getArrivalGate() returns NULL. </em><p>
Sources: <a class="el" href="tictoc10.ned.html">tictoc10.ned</a>, <a class="el" href="txc10.cc.html">txc10.cc</a>, <a class="el" href="omnetpp.ini.html">omnetpp.ini</a><h2><a class="anchor" name="s11">
Step 11: Channels and inner type definitions</a></h2>
Our new network definition is getting quite complex and long, especially the connections section. Let's try to simplify it. The first thing we notice is that the connections always use the same <code>delay</code> parameter. It is possible to create types for the connections (they are called channels) similarly to simple modules. We should create a channel type which specifies the delay parameter and we will use that type for all connections in the network.<p>
 <div class="fragment"><pre class="fragment">network Tictoc11
{
    types:
        channel Channel extends ned.DelayChannel {
            delay = 100ms;
        }
    submodules:
</pre></div><p>
As you have noticed we have defined the new channel type inside the network definition by adding a <code>types</code> section. This type definition is only visible inside the network. It is called as a local or inner type. You can use simple modules as inner types too, if you wish.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>We have created the channel by specializing the built-in DelayChannel. (built-in channels can be found inside the <code>ned</code> package. Thats why we used the full type name <code>ned.DelayChannel</code>) after the <code>extends</code> keyword.</dd></dl>
Now let's check how the <code>connections</code> section changed.<p>
 <div class="fragment"><pre class="fragment">    connections:
        tic[0].out++ --&gt; Channel --&gt; tic[1].in++;
        tic[0].in++ &lt;-- Channel &lt;-- tic[1].out++;

        tic[1].out++ --&gt; Channel --&gt; tic[2].in++;
        tic[1].in++ &lt;-- Channel &lt;-- tic[2].out++;

        tic[1].out++ --&gt; Channel --&gt; tic[4].in++;
        tic[1].in++ &lt;-- Channel &lt;-- tic[4].out++;

        tic[3].out++ --&gt; Channel --&gt; tic[4].in++;
        tic[3].in++ &lt;-- Channel &lt;-- tic[4].out++;

        tic[4].out++ --&gt; Channel --&gt; tic[5].in++;
        tic[4].in++ &lt;-- Channel &lt;-- tic[5].out++;
}
</pre></div><p>
As you see we just specify the channel name inside the connection definition. This allows to easily change the delay parameter for the whole network.<p>
Sources: <a class="el" href="tictoc11.ned.html">tictoc11.ned</a>, <a class="el" href="txc11.cc.html">txc11.cc</a>, <a class="el" href="omnetpp.ini.html">omnetpp.ini</a><h2><a class="anchor" name="s12">
Step 12: Using two-way connections</a></h2>
If we check the <code>connections</code> section a little more, we will realize that each node pair is connected with two connections. One for each direction. OMNeT++ 4 supports two way connections, so let's use them.<p>
First of all, we have to define two-way (or so called <code>inout</code>) gates instead of the separate <code>input</code> and <code>output</code> gates we used previously.<p>
 <div class="fragment"><pre class="fragment">simple <a class="code" href="classTxc12.html">Txc12</a>
{
    parameters:
        @display(<span class="stringliteral">"i=block/routing"</span>);
    gates:
        inout gate[];  <span class="comment">// declare two way connections</span>
}
</pre></div><p>
The new <code>connections</code> section would look like this:<p>
 <div class="fragment"><pre class="fragment">    connections:
        tic[0].gate++ &lt;--&gt; Channel &lt;--&gt; tic[1].gate++;
        tic[1].gate++ &lt;--&gt; Channel &lt;--&gt; tic[2].gate++;
        tic[1].gate++ &lt;--&gt; Channel &lt;--&gt; tic[4].gate++;
        tic[3].gate++ &lt;--&gt; Channel &lt;--&gt; tic[4].gate++;
        tic[4].gate++ &lt;--&gt; Channel &lt;--&gt; tic[5].gate++;
}
</pre></div><p>
We have modified the gate names so we have to make some modifications to the C++ code.<p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="classTxc12.html#0776d3640c16fdfcaa112ad4eb987415">Txc12::forwardMessage</a>(<a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> *msg)
{
    <span class="comment">// In this example, we just pick a random gate to send it on.</span>
    <span class="comment">// We draw a random number between 0 and the size of gate `gate[]'.</span>
    <span class="keywordtype">int</span> n = <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcModule.html#c63b0b9c805c5f335d274195f2fdb28c">gateSize</a>(<span class="stringliteral">"gate"</span>);
    <span class="keywordtype">int</span> k = <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//group__RandomNumbersDiscr.html#gee8ce6ae7e43b06e968a023f25c91b4f">intuniform</a>(0,n-1);

    <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//group__Envir.html#g650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">"Forwarding message "</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">" on gate["</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">"]\n"</span>;
    <span class="comment">// $o and $i suffix is used to identify the input/output part of a two way gate</span>
    <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcSimpleModule.html#94590ba6481116f29f4c43d00733deea">send</a>(msg, <span class="stringliteral">"gate$o"</span>, k);
}
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The special $i and $o suffix after the gate name allows us to use the connection's two direction separately.</dd></dl>
Sources: <a class="el" href="tictoc12.ned.html">tictoc12.ned</a>, <a class="el" href="txc12.cc.html">txc12.cc</a>, <a class="el" href="omnetpp.ini.html">omnetpp.ini</a><h2><a class="anchor" name="s13">
Step 13: Defining our message class</a></h2>
In this step the destination address is no longer hardcoded tic[3] -- we draw a random destination, and we'll add the destination address to the message.<p>
The best way is to subclass <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> and add destination as a data member. Hand-coding the message class is usually tedious because it contains a lot of boilerplate code, so we let OMNeT++ generate the class for us. The message class specification is in tictoc13.msg:<p>
 <div class="fragment"><pre class="fragment">message TicTocMsg13
{
    <span class="keywordtype">int</span> source;
    <span class="keywordtype">int</span> destination;
    <span class="keywordtype">int</span> hopCount = 0;
}
</pre></div><p>
The makefile is set up so that the message compiler, opp_msgc is invoked and it generates tictoc13_m.h and tictoc13_m.cc from the message declaration. They will contain a generated TicTocMsg13 class subclassed from <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a>; the class will have getter and setter methods for every field.<p>
We'll include tictoc13_m.h into our C++ code, and we can use TicTocMsg13 as any other class.<p>
 <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "tictoc13_m.h"</span>
</pre></div><p>
For example, we use the following lines in generateMessage() to create the message and fill its fields.<p>
<div class="fragment"><pre class="fragment">    TicTocMsg13 *msg = <span class="keyword">new</span> TicTocMsg13(msgname);
    msg-&gt;setSource(src);
    msg-&gt;setDestination(dest);
    <span class="keywordflow">return</span> msg;
</pre></div><p>
Then, handleMessage() begins like this:<p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="classTxc13.html#0453de5127489ee026d598cdb64f28a8">Txc13::handleMessage</a>(<a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> *msg)
{
    TicTocMsg13 *ttmsg = <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//group__Functions.html#gc05a322b9912da77f8b797eeab7805f4">check_and_cast</a>&lt;TicTocMsg13 *&gt;(msg);

    <span class="keywordflow">if</span> (ttmsg-&gt;getDestination()==<a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcModule.html#604e26394d77938a860eeb4452f25606">getIndex</a>())
</pre></div><p>
In the argument to handleMessage(), we get the message as a <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> * pointer. However, we can only access its fields defined in TicTocMsg13 if we cast msg to TicTocMsg13 *. Plain C-style cast (<code>(TicTocMsg13 *)msg</code>) is not safe because if the message is <em>not</em> a TicTocMsg13 after all the program will just crash, causing an error which is difficult to explore.<p>
C++ offers a solution which is called dynamic_cast. Here we use <a class="elRef" doxygen="opptags.xml:../api//" href="../api//group__Functions.html#gc05a322b9912da77f8b797eeab7805f4">check_and_cast&lt;&gt;()</a> which is provided by OMNeT++: it tries to cast the pointer via dynamic_cast, and if it fails it stops the simulation with an error message, similar to the following:<p>
<div align="center">
<img src="step10e.gif" alt="step10e.gif">
</div>
<p>
In the next line, we check if the destination address is the same as the node's address. The <code>getIndex()</code> member function returns the index of the module in the submodule vector (remember, in the NED file we declarared it as <code>tic: <a class="el" href="classTxc13.html">Txc13</a>[6]</code>, so our nodes have addresses 0..5).<p>
To make the model execute longer, after a message arrives to its destination the destination node will generate another message with a random destination address, and so forth. Read the full code: <a class="el" href="txc13.cc.html">txc13.cc</a>.<p>
When you run the model, it'll look like this:<p>
<div align="center">
<img src="step13a.png" alt="step13a.png">
</div>
<p>
You can double-click on the messages to open an inspector for them. (You'll either have to temporarily stop the simulation for that, or to be very fast in handling the mouse). The inspector window displays lots of useful information; the message fields can be seen on the Contents page.<p>
<div align="center">
<img src="step13b.png" alt="step13b.png">
</div>
<p>
Sources: <a class="el" href="tictoc13.ned.html">tictoc13.ned</a>, <a class="el" href="tictoc13.msg.html">tictoc13.msg</a>, <a class="el" href="txc13.cc.html">txc13.cc</a>, <a class="el" href="omnetpp.ini.html">omnetpp.ini</a><p>
<em>Exercise: In this model, there is only one message underway at any given moment: nodes only generate a message when another message arrives at them. We did it this way to make it easier to follow the simulation. Change the module class so that instead, it generates messages periodically. The interval between messages should be a module parameter, returning exponentially distributed random numbers. </em><p>
NEXT: <a class="el" href="part4.html">4. Adding statistics collection</a> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 3 14:40:30 2013 for Tictoc Tutorial by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
