<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>OMNeT++ Simulation Library: cclassdescriptor.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c1f96c663b8c6b82e9251148af4abcd0.html">include</a>
  </div>
</div>
</div>
<h1>cclassdescriptor.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//==========================================================================</span>
<a name="l00002"></a>00002 <span class="comment">//  CCLASSDESCRIPTOR.H - part of</span>
<a name="l00003"></a>00003 <span class="comment">//                     OMNeT++/OMNEST</span>
<a name="l00004"></a>00004 <span class="comment">//            Discrete System Simulation in C++</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">//  Declaration of the following classes:</span>
<a name="l00008"></a>00008 <span class="comment">//    cClassDescriptor  : metainfo about structs and classes</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">//==========================================================================</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="comment">/*--------------------------------------------------------------*</span>
<a name="l00013"></a>00013 <span class="comment">  Copyright (C) 1992-2008 Andras Varga</span>
<a name="l00014"></a>00014 <span class="comment">  Copyright (C) 2006-2008 OpenSim Ltd.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">  This file is distributed WITHOUT ANY WARRANTY. See the file</span>
<a name="l00017"></a>00017 <span class="comment">  `license' for details on this and other legal matters.</span>
<a name="l00018"></a>00018 <span class="comment">*--------------------------------------------------------------*/</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#ifndef __CCLASSDESCRIPTOR_H</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#define __CCLASSDESCRIPTOR_H</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include "cownedobject.h"</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include "simtime.h"</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 NAMESPACE_BEGIN
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 
<a name="l00047"></a><a class="code" href="classcClassDescriptor.html">00047</a> <span class="keyword">class </span>SIM_API <a class="code" href="classcClassDescriptor.html" title="Abstract base class for structure description classes, used mainly with message subclassing...">cClassDescriptor</a> : <span class="keyword">public</span> <a class="code" href="classcNoncopyableOwnedObject.html" title="Base class for cOwnedObject-based classes that do not wish to support assignment...">cNoncopyableOwnedObject</a>
<a name="l00048"></a>00048 {
<a name="l00049"></a>00049   <span class="keyword">public</span>:
<a name="l00051"></a>00051     <span class="keyword">enum</span> {
<a name="l00052"></a><a class="code" href="classcClassDescriptor.html#40a68fbfd841ade0d64d054e6860efe9b5d9931ef565f2292b1ff42939a29e76">00052</a>         FD_ISARRAY = 0x01,    
<a name="l00053"></a><a class="code" href="classcClassDescriptor.html#40a68fbfd841ade0d64d054e6860efe9bbf8b7dd92cf7178b320acda764249d6">00053</a>         FD_ISCOMPOUND = 0x02, 
<a name="l00054"></a><a class="code" href="classcClassDescriptor.html#40a68fbfd841ade0d64d054e6860efe9f82468f1ec3c7ba5b5812a81a1d0c083">00054</a>         FD_ISPOINTER = 0x04,  
<a name="l00055"></a><a class="code" href="classcClassDescriptor.html#40a68fbfd841ade0d64d054e6860efe9ba72fec7c3dfd36fe0030011963784ec">00055</a>         FD_ISCOBJECT = 0x08,  
<a name="l00056"></a><a class="code" href="classcClassDescriptor.html#40a68fbfd841ade0d64d054e6860efe9985fb5bf5073179ee7b59576a975dd38">00056</a>         FD_ISCOWNEDOBJECT = 0x10, 
<a name="l00057"></a><a class="code" href="classcClassDescriptor.html#40a68fbfd841ade0d64d054e6860efe9cecf6c17866919f371e8635b2fedda84">00057</a>         FD_ISEDITABLE = 0x20, 
<a name="l00058"></a>00058         FD_NONE = 0x0
<a name="l00059"></a>00059     };
<a name="l00060"></a>00060 
<a name="l00061"></a>00061   <span class="keyword">private</span>:
<a name="l00062"></a>00062     std::string baseclassname;
<a name="l00063"></a>00063     <a class="code" href="classcClassDescriptor.html" title="Abstract base class for structure description classes, used mainly with message subclassing...">cClassDescriptor</a> *baseclassdesc;
<a name="l00064"></a>00064     <span class="keywordtype">int</span> inheritancechainlength;
<a name="l00065"></a>00065     <span class="keywordtype">int</span> extendscobject;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   <span class="keyword">protected</span>:
<a name="l00068"></a>00068     <span class="comment">// utility functions for converting from/to strings</span>
<a name="l00069"></a>00069     <span class="keyword">static</span> std::string long2string(<span class="keywordtype">long</span> l);
<a name="l00070"></a>00070     <span class="keyword">static</span> <span class="keywordtype">long</span> string2long(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
<a name="l00071"></a>00071     <span class="keyword">static</span> std::string ulong2string(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> l);
<a name="l00072"></a>00072     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> string2ulong(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
<a name="l00073"></a>00073     <span class="keyword">static</span> std::string int642string(int64 l);
<a name="l00074"></a>00074     <span class="keyword">static</span> int64 string2int64(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
<a name="l00075"></a>00075     <span class="keyword">static</span> std::string uint642string(uint64 l);
<a name="l00076"></a>00076     <span class="keyword">static</span> uint64 string2uint64(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
<a name="l00077"></a>00077     <span class="keyword">static</span> std::string bool2string(<span class="keywordtype">bool</span> b);
<a name="l00078"></a>00078     <span class="keyword">static</span> <span class="keywordtype">bool</span> string2bool(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
<a name="l00079"></a>00079     <span class="keyword">static</span> std::string double2string(<span class="keywordtype">double</span> d);
<a name="l00080"></a>00080     <span class="keyword">static</span> std::string double2string(<a class="code" href="classSimTime.html" title="int64-based, fixed-point simulation time.">SimTime</a> t) {<span class="keywordflow">return</span> t.<a class="code" href="classSimTime.html#97cecbb52a8e12e67d94081b5742f14a" title="Converts to string.">str</a>();}
<a name="l00081"></a>00081     <span class="keyword">static</span> <span class="keywordtype">double</span> string2double(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
<a name="l00082"></a>00082     <span class="keyword">static</span> std::string enum2string(<span class="keywordtype">long</span> e, <span class="keyword">const</span> <span class="keywordtype">char</span> *enumname);
<a name="l00083"></a>00083     <span class="keyword">static</span> <span class="keywordtype">long</span> string2enum(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *enumname);
<a name="l00084"></a>00084     <span class="keyword">static</span> std::string oppstring2string(<span class="keyword">const</span> <span class="keywordtype">char</span> *s) {<span class="keywordflow">return</span> s?s:<span class="stringliteral">""</span>;}
<a name="l00085"></a>00085     <span class="keyword">static</span> std::string oppstring2string(<span class="keyword">const</span> <a class="code" href="classopp__string.html" title="Lightweight string class, used internally in some parts of OMNeT++.">opp_string</a>&amp; s) {<span class="keywordflow">return</span> s.<a class="code" href="classopp__string.html#a66a083b034ac9a5bb3e8f5eed8461b5" title="Return pointer to the string.">c_str</a>();}
<a name="l00086"></a>00086     <span class="keyword">static</span> std::string oppstring2string(<span class="keyword">const</span> std::string&amp; s)  {<span class="keywordflow">return</span> s;}
<a name="l00087"></a>00087     <span class="keyword">static</span> <span class="keywordtype">void</span> string2oppstring(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <a class="code" href="classopp__string.html" title="Lightweight string class, used internally in some parts of OMNeT++.">opp_string</a>&amp; str) {str = s?s:<span class="stringliteral">""</span>;}
<a name="l00088"></a>00088     <span class="keyword">static</span> <span class="keywordtype">void</span> string2oppstring(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, std::string&amp; str) {str = s?s:<span class="stringliteral">""</span>;}
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <span class="keyword">public</span>:
<a name="l00093"></a>00093 
<a name="l00097"></a>00097     <a class="code" href="classcClassDescriptor.html" title="Abstract base class for structure description classes, used mainly with message subclassing...">cClassDescriptor</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *classname, <span class="keyword">const</span> <span class="keywordtype">char</span> *_baseclassname=NULL);
<a name="l00098"></a>00098 
<a name="l00102"></a>00102     <span class="keyword">virtual</span> ~<a class="code" href="classcClassDescriptor.html" title="Abstract base class for structure description classes, used mainly with message subclassing...">cClassDescriptor</a>();
<a name="l00104"></a>00104 
<a name="l00107"></a>00107 
<a name="l00112"></a>00112     <span class="keyword">static</span> <a class="code" href="classcClassDescriptor.html" title="Abstract base class for structure description classes, used mainly with message subclassing...">cClassDescriptor</a> *getDescriptorFor(<span class="keyword">const</span> <span class="keywordtype">char</span> *classname);
<a name="l00113"></a>00113 
<a name="l00119"></a>00119     <span class="keyword">static</span> <a class="code" href="classcClassDescriptor.html" title="Abstract base class for structure description classes, used mainly with message subclassing...">cClassDescriptor</a> *getDescriptorFor(<a class="code" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> *<span class="keywordtype">object</span>);
<a name="l00121"></a>00121 
<a name="l00124"></a>00124 
<a name="l00130"></a><a class="code" href="classcClassDescriptor.html#24bc2122cebb722c0b92f90c0a4676cc">00130</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> doesSupport(<a class="code" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> *obj)<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00131"></a>00131 
<a name="l00135"></a>00135     <span class="keyword">virtual</span> <a class="code" href="classcClassDescriptor.html" title="Abstract base class for structure description classes, used mainly with message subclassing...">cClassDescriptor</a> *getBaseClassDescriptor() <span class="keyword">const</span>;
<a name="l00136"></a>00136 
<a name="l00140"></a>00140     <span class="keywordtype">bool</span> extendsCObject() <span class="keyword">const</span>;
<a name="l00141"></a>00141 
<a name="l00146"></a>00146     <span class="keywordtype">int</span> getInheritanceChainLength() <span class="keyword">const</span>;
<a name="l00147"></a>00147 
<a name="l00154"></a>00154     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getProperty(<span class="keyword">const</span> <span class="keywordtype">char</span> *propertyname) <span class="keyword">const</span> = 0;
<a name="l00155"></a>00155 
<a name="l00160"></a>00160     <span class="keyword">virtual</span> <span class="keywordtype">int</span> getFieldCount(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>) <span class="keyword">const</span> = 0;
<a name="l00161"></a>00161 
<a name="l00167"></a>00167     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getFieldName(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field) <span class="keyword">const</span> = 0;
<a name="l00168"></a>00168 
<a name="l00174"></a>00174     <span class="keyword">virtual</span> <span class="keywordtype">int</span> findField(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *fieldName) <span class="keyword">const</span>;
<a name="l00175"></a>00175 
<a name="l00182"></a>00182     <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getFieldTypeFlags(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field) <span class="keyword">const</span> = 0;
<a name="l00183"></a>00183 
<a name="l00186"></a>00186     <span class="keywordtype">bool</span> getFieldIsArray(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field)<span class="keyword"> const </span>{<span class="keywordflow">return</span> getFieldTypeFlags(<span class="keywordtype">object</span>, field) &amp; FD_ISARRAY;}
<a name="l00187"></a>00187     <span class="keywordtype">bool</span> getFieldIsCompound(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field)<span class="keyword"> const </span>{<span class="keywordflow">return</span> getFieldTypeFlags(<span class="keywordtype">object</span>, field) &amp; FD_ISCOMPOUND;}
<a name="l00188"></a>00188     <span class="keywordtype">bool</span> getFieldIsPointer(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field)<span class="keyword"> const </span>{<span class="keywordflow">return</span> getFieldTypeFlags(<span class="keywordtype">object</span>, field) &amp; FD_ISPOINTER;}
<a name="l00189"></a>00189     <span class="keywordtype">bool</span> getFieldIsCObject(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field)<span class="keyword"> const </span>{<span class="keywordflow">return</span> getFieldTypeFlags(<span class="keywordtype">object</span>, field) &amp; (FD_ISCOBJECT|FD_ISCOWNEDOBJECT);}
<a name="l00190"></a>00190     <span class="keywordtype">bool</span> getFieldIsCOwnedObject(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field)<span class="keyword"> const </span>{<span class="keywordflow">return</span> getFieldTypeFlags(<span class="keywordtype">object</span>, field) &amp; FD_ISCOWNEDOBJECT;}
<a name="l00191"></a>00191     <span class="keywordtype">bool</span> getFieldIsEditable(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field)<span class="keyword"> const </span>{<span class="keywordflow">return</span> getFieldTypeFlags(<span class="keywordtype">object</span>, field) &amp; FD_ISEDITABLE;}
<a name="l00193"></a>00193 
<a name="l00197"></a>00197     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getFieldDeclaredOn(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field) <span class="keyword">const</span>;
<a name="l00198"></a>00198 
<a name="l00204"></a>00204     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getFieldTypeString(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field) <span class="keyword">const</span> = 0;
<a name="l00205"></a>00205 
<a name="l00212"></a>00212     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getFieldProperty(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field, <span class="keyword">const</span> <span class="keywordtype">char</span> *propertyname) <span class="keyword">const</span> = 0;
<a name="l00213"></a>00213 
<a name="l00218"></a>00218     <span class="keyword">virtual</span> <span class="keywordtype">int</span> getArraySize(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field) <span class="keyword">const</span> = 0;
<a name="l00219"></a>00219 
<a name="l00225"></a>00225     <span class="keyword">virtual</span> std::string getFieldAsString(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field, <span class="keywordtype">int</span> i) <span class="keyword">const</span> = 0;
<a name="l00226"></a>00226 
<a name="l00230"></a>00230     _OPPDEPRECATED <span class="keyword">virtual</span> <span class="keywordtype">bool</span> getFieldAsString(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field, <span class="keywordtype">int</span> i, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize) <span class="keyword">const</span>;
<a name="l00231"></a>00231 
<a name="l00238"></a>00238     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> setFieldAsString(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field, <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">char</span> *value) <span class="keyword">const</span> = 0;
<a name="l00239"></a>00239 
<a name="l00245"></a>00245     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getFieldStructName(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field) <span class="keyword">const</span> = 0;
<a name="l00246"></a>00246 
<a name="l00251"></a>00251     <span class="keyword">virtual</span> <span class="keywordtype">void</span> *getFieldStructPointer(<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keywordtype">int</span> field, <span class="keywordtype">int</span> i) <span class="keyword">const</span> = 0;
<a name="l00253"></a>00253 };
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 <span class="comment">// TODO remove this compatibili1y hack after OMNeT++ 4.3</span>
<a name="l00256"></a>00256 <span class="comment">// This is required for compatibility with INET 2.0 as it assumed that</span>
<a name="l00257"></a>00257 <span class="comment">// once OMNeT++ 4.3 released, it will change the getArraySize method</span>
<a name="l00258"></a>00258 <span class="comment">// to getFieldArraySize. This did not happen so we have to emulate</span>
<a name="l00259"></a>00259 <span class="comment">// this change only for the INET project.</span>
<a name="l00260"></a>00260 <span class="comment">//</span>
<a name="l00261"></a>00261 <span class="preprocessor">#if ((defined _MANET_COMPATIBILITY_H || defined __INET_MESSAGECHECKER_H) &amp;&amp; OMNETPP_VERSION == 0x0403)</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span><span class="preprocessor">#define getFieldArraySize    getArraySize</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span>
<a name="l00265"></a>00265 NAMESPACE_END
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="preprocessor">#endif</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span>
<a name="l00270"></a>00270 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 3 14:40:27 2013 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
