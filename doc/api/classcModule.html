<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>OMNeT++ Simulation Library: cModule Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cModule Class Reference<br>
<small>
[<a class="el" href="group__SimCore.html">Simulation core classes</a>]</small>
</h1><!-- doxytag: class="cModule" --><!-- doxytag: inherits="cComponent" --><code>#include &lt;<a class="el" href="cmodule_8h-source.html">cmodule.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for cModule:</div>
<div class="dynsection">

<p><center><img src="classcModule.png" usemap="#cModule_map" border="0" alt=""></center>
<map name="cModule_map">
<area href="classcComponent.html" alt="cComponent" shape="rect" coords="90,280,261,304">
<area href="classcDefaultList.html" alt="cDefaultList" shape="rect" coords="90,224,261,248">
<area href="classcNoncopyableOwnedObject.html" alt="cNoncopyableOwnedObject" shape="rect" coords="90,168,261,192">
<area href="classcOwnedObject.html" alt="cOwnedObject" shape="rect" coords="0,112,171,136">
<area href="classnoncopyable.html" alt="noncopyable" shape="rect" coords="181,112,352,136">
<area href="classcNamedObject.html" alt="cNamedObject" shape="rect" coords="0,56,171,80">
<area href="classcObject.html" alt="cObject" shape="rect" coords="0,0,171,24">
<area href="classcCompoundModule.html" alt="cCompoundModule" shape="rect" coords="0,392,171,416">
<area href="classcSimpleModule.html" alt="cSimpleModule" shape="rect" coords="181,392,352,416">
</map>
</div>

<p>
<a href="classcModule-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Common base for <a class="el" href="classcSimpleModule.html" title="Base class for all simple module classes.">cSimpleModule</a> and <a class="el" href="classcCompoundModule.html" title="Represents a compound module in the simulation.">cCompoundModule</a>. 
<p>
<a class="el" href="classcModule.html" title="Common base for cSimpleModule and cCompoundModule.">cModule</a> provides gates, parameters, RNG mapping, display strings, and a set of virtual methods.<p>
For navigating the module tree, see: <a class="el" href="classcModule.html#6e487556d9301e41654d25c767d58148" title="Returns the module containing this module.">getParentModule()</a>, <a class="el" href="classcModule.html#99f25de7d151adbe802c9b8811ee8e5b" title="Finds a direct submodule with the given name and index, and returns its pointer.">getSubmodule()</a>, <a class="el" href="classcModule_1_1SubmoduleIterator.html" title="Iterates through submodules of a compound module.">cModule::SubmoduleIterator</a>, <a class="el" href="classcModule.html#e77393ee1923a33e6fe59e6373964f19" title="Finds a module in this module&#39;s subtree, given with its relative path.">getModuleByRelativePath()</a>, <a class="el" href="classcSimulation.html#d74570b2e108672859083a667a353e47" title="Finds a module by its path.">cSimulation::getModuleByPath()</a>. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor, assignment.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a91df47dc373480450b61c62fbad934c">cModule</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#6a621fa6673160bb69c7dc4fe9eb64c8">~cModule</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Redefined cObject member functions.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#091296dfd37373944cb1532b5c11dd87">forEachChild</a> (<a class="el" href="classcVisitor.html">cVisitor</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#146a9b2d1c67a5c8bb1b54700fca465d">setName</a> (const char *s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#8adab0f2496267094680580de65fe1a0">getFullName</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#6aa348e7021a44dd3ce9170569ee210a">getFullPath</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Setting up the module.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#7e62ef5ed283503f29923fea5f2db310">addGate</a> (const char *gatename, <a class="el" href="classcGate.html#c548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a> type, bool isvector=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#aa4fcf1c668078ab20be7f56ced5c5d6">setGateSize</a> (const char *gatename, int size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#26cef93c2761379ac06ae4b2d66ade27">getOrCreateFirstUnconnectedGate</a> (const char *gatename, char suffix, bool inside, bool expand)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#8995ef1fc6ed92f6b833cf9c9ad1b88f">getOrCreateFirstUnconnectedGatePair</a> (const char *gatename, bool inside, bool expand, <a class="el" href="classcGate.html">cGate</a> *&amp;gatein, <a class="el" href="classcGate.html">cGate</a> *&amp;gateout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#4bbe79e47eae7740fa696afaf0f5f031">finalizeParameters</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#086c439380f400dc6254b5b2d5f1d408">buildInside</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Information about the module itself.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#71ee3edc64c50bd9efa5b8d43d155d99">isSimple</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#ad70f0f04b3a3ec056d2fd139edc30ee">isModule</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#5cd9789d5e4e5c7ee172cb5f251e3951">isPlaceholder</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcModule.html">cModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#6e487556d9301e41654d25c767d58148">getParentModule</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcModuleType.html">cModuleType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#32187b0d8cfa7cee175432073caf6d5c">getModuleType</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcProperties.html">cProperties</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#7d6ccba3d30c32fdb3997093f36872a5">getProperties</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#592b754c94045c707e4f5155f00c18f2">getId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#bc24e9322a19c30da173000110f26596">isVector</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#604e26394d77938a860eeb4452f25606">getIndex</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#0a24114f974cfae3444806bd951fc948">getVectorSize</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#d08955e71fd144469a04f0ea26c22766">size</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Submodule access.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#4c8b47a44c467739610b96d1a2fa979e">findSubmodule</a> (const char *submodname, int idx=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#99f25de7d151adbe802c9b8811ee8e5b">getSubmodule</a> (const char *submodname, int idx=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_OPPDEPRECATED <a class="el" href="classcModule.html">cModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#e77393ee1923a33e6fe59e6373964f19">getModuleByRelativePath</a> (const char *path)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a2b5815855954afa5056ea8df9a98001">getModuleByPath</a> (const char *path)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Gates.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#c81230070167bdc3db38300ea101f1ab">gate</a> (const char *gatename, int index=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#8a8361fffa84de74b8bf6b549c70543b">gate</a> (const char *gatename, int index=-1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#d9aedd5fd1dbcfe37baed7e4526c8c8d">gateHalf</a> (const char *gatename, <a class="el" href="classcGate.html#c548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a> type, int index=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#1a67e61c277bb1d92b0ac3a5c38acfd5">gateHalf</a> (const char *gatename, <a class="el" href="classcGate.html#c548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a> type, int index=-1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#6ced7b6cd78db73cb1506a5ec15dc562">hasGate</a> (const char *gatename, int index=-1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a1c2b8a89896d26041a0cdb1bdd11336">findGate</a> (const char *gatename, int index=-1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#106e3be27a4f665deb922d125bf6936a">gate</a> (int id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classcGate.html">cGate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#604d651ab2c45c51c11712ac1e86c9ce">gate</a> (int id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#3beb4e7ef94e2b8cff4a5b90fcb7c743">deleteGate</a> (const char *gatename)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector&lt; const char * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#97e1b240b3f4c566436180a6471a850b">getGateNames</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcGate.html#c548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#fdbf2cebc7f52d6518c6f67819d1ec76">gateType</a> (const char *gatename) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#4f373def6f1b151fea20a4b8e72de9f6">isGateVector</a> (const char *gatename) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#c63b0b9c805c5f335d274195f2fdb28c">gateSize</a> (const char *gatename) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#4d11f590eb1770be0e418da02c68e785">gateBaseId</a> (const char *gatename) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#bd0b3bd68688e456141f855b16a8f836">checkInternalConnections</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Utilities.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcPar.html">cPar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#d59a57aa7f6b19ff0061cbd87917cb74">getAncestorPar</a> (const char *parname)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Public methods for invoking initialize()/finish(), redefined from cComponent.</div></td></tr>
<tr><td colspan="2"><div class="groupText">initialize(), numInitStages(), and finish() are themselves also declared in <a class="el" href="classcComponent.html" title="Common base for module and channel classes: cModule and cChannel.">cComponent</a>, and can be redefined in simple modules by the user to perform initialization and finalization (result recording, etc) tasks. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#2479e23e50fd2286730892ef59cc784e">callInitialize</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#fa97027522d4296a3436a6bb5cd2fa6e">callInitialize</a> (int stage)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#200cedd49110c4b22018dd7ce669b073">callFinish</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Dynamic module creation.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#aaed82aec8392c256d984b7975384d0c">scheduleStart</a> (simtime_t t)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#a40e04f3a15395bfad553227c0a51866">deleteModule</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#f9e5fae012b14606d5e58cab261c91af">changeParentTo</a> (<a class="el" href="classcModule.html">cModule</a> *mod)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#dd01a066cdec92f7f5fc3f455abfb225">doBuildInside</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d65e9293fb55c44ed30eef8b1f27df95"></a><!-- doxytag: member="cModule::cGate" ref="d65e9293fb55c44ed30eef8b1f27df95" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#d65e9293fb55c44ed30eef8b1f27df95">cGate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c6add72105ce0170138d90021da4d97"></a><!-- doxytag: member="cModule::cSimulation" ref="3c6add72105ce0170138d90021da4d97" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#3c6add72105ce0170138d90021da4d97">cSimulation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c019ff97fbe4ac5f1ed4f9e2953a8573"></a><!-- doxytag: member="cModule::cModuleType" ref="c019ff97fbe4ac5f1ed4f9e2953a8573" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#c019ff97fbe4ac5f1ed4f9e2953a8573">cModuleType</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34161f0247581027e5e313d34f76fdbf"></a><!-- doxytag: member="cModule::cChannelType" ref="34161f0247581027e5e313d34f76fdbf" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule.html#34161f0247581027e5e313d34f76fdbf">cChannelType</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule_1_1ChannelIterator.html">ChannelIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walks along the channels inside a module, that is, the channels among the module and its submodules.  <a href="classcModule_1_1ChannelIterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule_1_1GateIterator.html">GateIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates through the gates of a module.  <a href="classcModule_1_1GateIterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcModule_1_1SubmoduleIterator.html">SubmoduleIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates through submodules of a compound module.  <a href="classcModule_1_1SubmoduleIterator.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a91df47dc373480450b61c62fbad934c"></a><!-- doxytag: member="cModule::cModule" ref="a91df47dc373480450b61c62fbad934c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cModule::cModule           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
Note that module objects should not be created directly, only via their <a class="el" href="classcModuleType.html" title="Abstract class for creating a module of a specific type.">cModuleType</a> objects. <a class="el" href="classcModuleType.html#60287ca91b5283cf33bc03b7d45fc2cb" title="Creates a module which is not element of a module vector.">cModuleType::create()</a> will do all housekeeping tasks associated with module creation (assigning an ID to the module, inserting it into the global <code>simulation</code> object (see <a class="el" href="classcSimulation.html" title="Simulation manager class.">cSimulation</a>), etc.). 
</div>
</div><p>
<a class="anchor" name="6a621fa6673160bb69c7dc4fe9eb64c8"></a><!-- doxytag: member="cModule::~cModule" ref="6a621fa6673160bb69c7dc4fe9eb64c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual cModule::~cModule           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dd01a066cdec92f7f5fc3f455abfb225"></a><!-- doxytag: member="cModule::doBuildInside" ref="dd01a066cdec92f7f5fc3f455abfb225" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::doBuildInside           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal function for <a class="el" href="classcModule.html#086c439380f400dc6254b5b2d5f1d408" title="In compound modules, this method should be called to create submodules and internal...">buildInside()</a>, it should not be invoked directly. 
<p>
Should be refined in subclasses representing compound modules to build submodule and internal connections of this module. This default implementation does nothing. 
<p>Reimplemented in <a class="el" href="classcCompoundModule.html#0dea1309f63f8bfe1f409881eb271e91">cCompoundModule</a>.</p>

</div>
</div><p>
<a class="anchor" name="091296dfd37373944cb1532b5c11dd87"></a><!-- doxytag: member="cModule::forEachChild" ref="091296dfd37373944cb1532b5c11dd87" args="(cVisitor *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::forEachChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcVisitor.html">cVisitor</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls v-&gt;visit(this) for each contained object. 
<p>
See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. 
<p>Reimplemented from <a class="el" href="classcComponent.html#942c1c9d273567b34947659151f52d76">cComponent</a>.</p>

<p>Reimplemented in <a class="el" href="classcSimpleModule.html#e6c2cca1385f7e0cea5c5a100e4cfb69">cSimpleModule</a>.</p>

</div>
</div><p>
<a class="anchor" name="146a9b2d1c67a5c8bb1b54700fca465d"></a><!-- doxytag: member="cModule::setName" ref="146a9b2d1c67a5c8bb1b54700fca465d" args="(const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::setName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets object's name. 
<p>
Redefined to update the stored fullName string. 
<p>Reimplemented from <a class="el" href="classcNamedObject.html#fdad5d1296c7c90d494dacfa42d9b5c4">cNamedObject</a>.</p>

</div>
</div><p>
<a class="anchor" name="8adab0f2496267094680580de65fe1a0"></a><!-- doxytag: member="cModule::getFullName" ref="8adab0f2496267094680580de65fe1a0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* cModule::getFullName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the full name of the module, which is <a class="el" href="classcNamedObject.html#5b06a5fdb473bb997c939ba55435c041" title="Returns pointer to the object&#39;s name, a string stored in the object.">getName()</a> plus the index in square brackets (e.g. 
<p>
"module[4]"). Redefined to add the index. 
<p>Reimplemented from <a class="el" href="classcObject.html#b99d95f3760383d74095668b2939c08f">cObject</a>.</p>

</div>
</div><p>
<a class="anchor" name="6aa348e7021a44dd3ce9170569ee210a"></a><!-- doxytag: member="cModule::getFullPath" ref="6aa348e7021a44dd3ce9170569ee210a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cModule::getFullPath           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the full path name of the module. 
<p>
Example: <code>"net.node[12].gen"</code>. The original <a class="el" href="classcModule.html#6aa348e7021a44dd3ce9170569ee210a" title="Returns the full path name of the module.">getFullPath()</a> was redefined in order to hide the global <a class="el" href="classcSimulation.html" title="Simulation manager class.">cSimulation</a> instance from the path name. 
<p>Reimplemented from <a class="el" href="classcObject.html#26c918d8176ea1ce3bc6b87cc7e45464">cObject</a>.</p>

</div>
</div><p>
<a class="anchor" name="7e62ef5ed283503f29923fea5f2db310"></a><!-- doxytag: member="cModule::addGate" ref="7e62ef5ed283503f29923fea5f2db310" args="(const char *gatename, cGate::Type type, bool isvector=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::addGate           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html#c548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isvector</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a gate or gate vector to the module. 
<p>
Gate vectors are created with zero size. When the creation of a (non-vector) gate of type cGate::INOUT is requested, actually two gate objects will be created, "gatename$i" and "gatename$o". The specified gatename must not contain a "$i" or "$o" suffix itself.<p>
CAUTION: The return value is only valid when a non-vector INPUT or OUTPUT gate was requested. NULL gets returned for INOUT gates and gate vectors. 
</div>
</div><p>
<a class="anchor" name="aa4fcf1c668078ab20be7f56ced5c5d6"></a><!-- doxytag: member="cModule::setGateSize" ref="aa4fcf1c668078ab20be7f56ced5c5d6" args="(const char *gatename, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::setGateSize           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets gate vector size. 
<p>
The specified gatename must not contain a "$i" or "$o" suffix: it is not possible to set different vector size for the "$i" or "$o" parts of an inout gate. Changing gate vector size is guaranteed NOT to change any gate IDs. 
</div>
</div><p>
<a class="anchor" name="26cef93c2761379ac06ae4b2d66ade27"></a><!-- doxytag: member="cModule::getOrCreateFirstUnconnectedGate" ref="26cef93c2761379ac06ae4b2d66ade27" args="(const char *gatename, char suffix, bool inside, bool expand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::getOrCreateFirstUnconnectedGate           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>expand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function for implementing NED's "gate++" syntax. 
<p>
Returns the next unconnected gate from an input or output gate vector, or input/output half of an inout vector. When gatename names an inout gate vector, the suffix parameter should be set to 'i' or 'o' to select "gatename$i" or "gatename$o"; otherwise suffix should be zero. The inside parameter selects whether to use isConnectedInside() or isConnectedOutside() to test if the gate is connected. The expand parameter tells whether the gate vector should be expanded if all its gates are used up. 
</div>
</div><p>
<a class="anchor" name="8995ef1fc6ed92f6b833cf9c9ad1b88f"></a><!-- doxytag: member="cModule::getOrCreateFirstUnconnectedGatePair" ref="8995ef1fc6ed92f6b833cf9c9ad1b88f" args="(const char *gatename, bool inside, bool expand, cGate *&amp;gatein, cGate *&amp;gateout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::getOrCreateFirstUnconnectedGatePair           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html">cGate</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>gatein</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html">cGate</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>gateout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function to implement NED's "gate++" syntax. 
<p>
This variant accepts inout gates only, and the result is returned in the gatein and gateout parameters. The meaning of the inside and expand parameters is the same as with <a class="el" href="classcModule.html#26cef93c2761379ac06ae4b2d66ade27" title="Helper function for implementing NED&#39;s &quot;gate++&quot; syntax.">getOrCreateFirstUnconnectedGate()</a>. 
</div>
</div><p>
<a class="anchor" name="4bbe79e47eae7740fa696afaf0f5f031"></a><!-- doxytag: member="cModule::finalizeParameters" ref="4bbe79e47eae7740fa696afaf0f5f031" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::finalizeParameters           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Redefined from <a class="el" href="classcComponent.html" title="Common base for module and channel classes: cModule and cChannel.">cComponent</a>. 
<p>
This method must be called as part of the module creation process, after moduleType-&gt;create() and before mod-&gt;<a class="el" href="classcModule.html#086c439380f400dc6254b5b2d5f1d408" title="In compound modules, this method should be called to create submodules and internal...">buildInside()</a>. It finalizes parameter values (e.g. reads the missing ones from omnetpp.ini), and adds gates and gate vectors (whose size may depend on parameter values) to the module.<p>
So the sequence of setting up a module is: 1. modType-&gt;create() 2. set parameter values 3. mod-&gt;<a class="el" href="classcModule.html#4bbe79e47eae7740fa696afaf0f5f031" title="Redefined from cComponent.">finalizeParameters()</a> -- this creates gates too 4. connect gates (possibly adding new gates via gate++ operations) 5. mod-&gt;<a class="el" href="classcModule.html#086c439380f400dc6254b5b2d5f1d408" title="In compound modules, this method should be called to create submodules and internal...">buildInside()</a><p>
The above sequence also explains why <a class="el" href="classcModule.html#4bbe79e47eae7740fa696afaf0f5f031" title="Redefined from cComponent.">finalizeParameters()</a> cannot by merged into either create() or <a class="el" href="classcModule.html#086c439380f400dc6254b5b2d5f1d408" title="In compound modules, this method should be called to create submodules and internal...">buildInside()</a>. 
<p>Reimplemented from <a class="el" href="classcComponent.html#48d55859565b5f34616adeac268040e6">cComponent</a>.</p>

</div>
</div><p>
<a class="anchor" name="086c439380f400dc6254b5b2d5f1d408"></a><!-- doxytag: member="cModule::buildInside" ref="086c439380f400dc6254b5b2d5f1d408" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int cModule::buildInside           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
In compound modules, this method should be called to create submodules and internal connections after module creation. 
<p>
This method delegates to <a class="el" href="classcModule.html#dd01a066cdec92f7f5fc3f455abfb225" title="Internal function for buildInside(), it should not be invoked directly.">doBuildInside()</a>, switching the context to this module for the duration of the call (see simulation.setContextModule()).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcModule.html#dd01a066cdec92f7f5fc3f455abfb225" title="Internal function for buildInside(), it should not be invoked directly.">doBuildInside()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="71ee3edc64c50bd9efa5b8d43d155d99"></a><!-- doxytag: member="cModule::isSimple" ref="71ee3edc64c50bd9efa5b8d43d155d99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::isSimple           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function. 
<p>
Returns true this is a simple module (i.e. subclassed from <a class="el" href="classcSimpleModule.html" title="Base class for all simple module classes.">cSimpleModule</a>), false otherwise. 
</div>
</div><p>
<a class="anchor" name="ad70f0f04b3a3ec056d2fd139edc30ee"></a><!-- doxytag: member="cModule::isModule" ref="ad70f0f04b3a3ec056d2fd139edc30ee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::isModule           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Redefined from <a class="el" href="classcComponent.html" title="Common base for module and channel classes: cModule and cChannel.">cComponent</a> to return true. 
<p>

<p>Reimplemented from <a class="el" href="classcComponent.html#45d487696267e78b4424258fe0005e60">cComponent</a>.</p>

</div>
</div><p>
<a class="anchor" name="5cd9789d5e4e5c7ee172cb5f251e3951"></a><!-- doxytag: member="cModule::isPlaceholder" ref="5cd9789d5e4e5c7ee172cb5f251e3951" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::isPlaceholder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this module is a placeholder module, i.e. 
<p>
represents a remote module in a parallel simulation run. 
</div>
</div><p>
<a class="anchor" name="6e487556d9301e41654d25c767d58148"></a><!-- doxytag: member="cModule::getParentModule" ref="6e487556d9301e41654d25c767d58148" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcModule.html">cModule</a>* cModule::getParentModule           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the module containing this module. 
<p>
For the system module, it returns NULL. 
<p>Implements <a class="el" href="classcComponent.html#54ae9602442ca021ce8f660cd0b9969a">cComponent</a>.</p>

</div>
</div><p>
<a class="anchor" name="32187b0d8cfa7cee175432073caf6d5c"></a><!-- doxytag: member="cModule::getModuleType" ref="32187b0d8cfa7cee175432073caf6d5c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcModuleType.html">cModuleType</a>* cModule::getModuleType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method: casts the return value of <a class="el" href="classcComponent.html#4908a781e9c0da8d720ed4c1a324a591" title="Returns the associated component type.">getComponentType()</a> to <a class="el" href="classcModuleType.html" title="Abstract class for creating a module of a specific type.">cModuleType</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="7d6ccba3d30c32fdb3997093f36872a5"></a><!-- doxytag: member="cModule::getProperties" ref="7d6ccba3d30c32fdb3997093f36872a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcProperties.html">cProperties</a>* cModule::getProperties           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the properties for this module. 
<p>
Properties cannot be changed at runtime. Redefined from <a class="el" href="classcComponent.html" title="Common base for module and channel classes: cModule and cChannel.">cComponent</a>. 
<p>Implements <a class="el" href="classcComponent.html#474370c3157dbd6eb9203f8543ae40b1">cComponent</a>.</p>

</div>
</div><p>
<a class="anchor" name="592b754c94045c707e4f5155f00c18f2"></a><!-- doxytag: member="cModule::getId" ref="592b754c94045c707e4f5155f00c18f2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cModule::getId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the module ID. 
<p>
It is actually the index of the module in the module vector within the <a class="el" href="classcSimulation.html" title="Simulation manager class.">cSimulation</a> simulation object. Module IDs are guaranteed to be unique during a simulation run (that is, IDs of deleted modules are not given out to newly created modules).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcSimulation.html#4a52271d194b889ea9013c84a6501435" title="Looks up a module by ID.">cSimulation::getModule()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc24e9322a19c30da173000110f26596"></a><!-- doxytag: member="cModule::isVector" ref="bc24e9322a19c30da173000110f26596" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cModule::isVector           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this module is in a module vector. 
<p>

</div>
</div><p>
<a class="anchor" name="604e26394d77938a860eeb4452f25606"></a><!-- doxytag: member="cModule::getIndex" ref="604e26394d77938a860eeb4452f25606" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cModule::getIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the module if it is in a module vector, otherwise 0. 
<p>

</div>
</div><p>
<a class="anchor" name="0a24114f974cfae3444806bd951fc948"></a><!-- doxytag: member="cModule::getVectorSize" ref="0a24114f974cfae3444806bd951fc948" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cModule::getVectorSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the size of the module vector the module is in. 
<p>
For non-vector modules it returns 1. 
</div>
</div><p>
<a class="anchor" name="d08955e71fd144469a04f0ea26c22766"></a><!-- doxytag: member="cModule::size" ref="d08955e71fd144469a04f0ea26c22766" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cModule::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="classcModule.html#0a24114f974cfae3444806bd951fc948" title="Returns the size of the module vector the module is in.">getVectorSize()</a>. 
<p>

<p>Referenced by <a class="el" href="csimulation_8h-source.html#l00212">cSimulation::getModule()</a>, and <a class="el" href="csimulation_8h-source.html#l00219">cSimulation::operator[]()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4c8b47a44c467739610b96d1a2fa979e"></a><!-- doxytag: member="cModule::findSubmodule" ref="4c8b47a44c467739610b96d1a2fa979e" args="(const char *submodname, int idx=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cModule::findSubmodule           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>submodname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a direct submodule with the given name and index, and returns its module ID. 
<p>
If the submodule was not found, returns -1. Index must be specified exactly if the module is member of a module vector. 
</div>
</div><p>
<a class="anchor" name="99f25de7d151adbe802c9b8811ee8e5b"></a><!-- doxytag: member="cModule::getSubmodule" ref="99f25de7d151adbe802c9b8811ee8e5b" args="(const char *submodname, int idx=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcModule.html">cModule</a>* cModule::getSubmodule           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>submodname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a direct submodule with the given name and index, and returns its pointer. 
<p>
If the submodule was not found, returns NULL. Index must be specified exactly if the module is member of a module vector. 
</div>
</div><p>
<a class="anchor" name="e77393ee1923a33e6fe59e6373964f19"></a><!-- doxytag: member="cModule::getModuleByRelativePath" ref="e77393ee1923a33e6fe59e6373964f19" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_OPPDEPRECATED <a class="el" href="classcModule.html">cModule</a>* cModule::getModuleByRelativePath           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a module in this module's subtree, given with its relative path. 
<p>
The path is a string of module names separated by dots. Returns NULL if the module was not found.<p>
Deprecated: please use the more powerful <a class="el" href="classcModule.html#a2b5815855954afa5056ea8df9a98001" title="Finds a module in the module tree, given by its absolute or relative path.">getModuleByPath()</a> instead. 
</div>
</div><p>
<a class="anchor" name="a2b5815855954afa5056ea8df9a98001"></a><!-- doxytag: member="cModule::getModuleByPath" ref="a2b5815855954afa5056ea8df9a98001" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcModule.html">cModule</a>* cModule::getModuleByPath           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a module in the module tree, given by its absolute or relative path. 
<p>
The path is a string of module names separated by dots; the special module name ^ (caret) stands for the parent module. If the path starts with a dot or caret, it is understood as relative to this module, otherwise it is taken to mean an absolute path. For absolute paths, inclusion of the toplevel module's name in the path is optional. Returns NULL if the module was not found.<p>
Examples: ".sink" means the sink submodule; ".queue[2].srv" means the srv submodule of the queue[2] submodule; "^.host2" or ".^.host2" means the host2 sibling module; "src" or "Net.src" means the top src module (provided the network is called Net); "." means this module.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcSimulation.html#d74570b2e108672859083a667a353e47" title="Finds a module by its path.">cSimulation::getModuleByPath()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c81230070167bdc3db38300ea101f1ab"></a><!-- doxytag: member="cModule::gate" ref="c81230070167bdc3db38300ea101f1ab" args="(const char *gatename, int index=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::gate           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up a gate by its name and index. 
<p>
Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. 
</div>
</div><p>
<a class="anchor" name="8a8361fffa84de74b8bf6b549c70543b"></a><!-- doxytag: member="cModule::gate" ref="8a8361fffa84de74b8bf6b549c70543b" args="(const char *gatename, int index=-1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcGate.html">cGate</a>* cModule::gate           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up a gate by its name and index. 
<p>
Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. 
</div>
</div><p>
<a class="anchor" name="d9aedd5fd1dbcfe37baed7e4526c8c8d"></a><!-- doxytag: member="cModule::gateHalf" ref="d9aedd5fd1dbcfe37baed7e4526c8c8d" args="(const char *gatename, cGate::Type type, int index=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::gateHalf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html#c548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the "$i" or "$o" part of an inout gate, depending on the type parameter. 
<p>
That is, gateHalf("port", cGate::OUTPUT, 3) would return gate "port$o[3]". Throws an error if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. 
</div>
</div><p>
<a class="anchor" name="1a67e61c277bb1d92b0ac3a5c38acfd5"></a><!-- doxytag: member="cModule::gateHalf" ref="1a67e61c277bb1d92b0ac3a5c38acfd5" args="(const char *gatename, cGate::Type type, int index=-1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcGate.html">cGate</a>* cModule::gateHalf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html#c548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the "$i" or "$o" part of an inout gate, depending on the type parameter. 
<p>
That is, gateHalf("port", cGate::OUTPUT, 3) would return gate "port$o[3]". Throws an error if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. 
</div>
</div><p>
<a class="anchor" name="6ced7b6cd78db73cb1506a5ec15dc562"></a><!-- doxytag: member="cModule::hasGate" ref="6ced7b6cd78db73cb1506a5ec15dc562" args="(const char *gatename, int index=-1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::hasGate           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if a gate exists. 
<p>
When invoked without index, it returns whether gate "gatename" or "gatename[]" exists (no matter if the gate vector size is currently zero). When invoked with an index, it returns whether the concrete "gatename[index]" gate exists (gatename being a vector gate). Gate names with the "$i" or "$o" suffix are also accepted. 
</div>
</div><p>
<a class="anchor" name="a1c2b8a89896d26041a0cdb1bdd11336"></a><!-- doxytag: member="cModule::findGate" ref="a1c2b8a89896d26041a0cdb1bdd11336" args="(const char *gatename, int index=-1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int cModule::findGate           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the ID of the gate specified by name and index. 
<p>
Inout gates cannot be specified (since they are actually two gate objects, not one), only with a "$i" or "$o" suffix. Returns -1 if the gate does not exist. The presence of the index parameter decides whether a vector or a scalar gate will be looked for. 
</div>
</div><p>
<a class="anchor" name="106e3be27a4f665deb922d125bf6936a"></a><!-- doxytag: member="cModule::gate" ref="106e3be27a4f665deb922d125bf6936a" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html">cGate</a>* cModule::gate           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a gate by its ID. 
<p>
It throws an error for invalid (or stale) IDs.<p>
Note: as of OMNeT++ 4.0, gate IDs are no longer small integers and are not suitable for enumerating all gates of a module. Use <a class="el" href="classcModule_1_1GateIterator.html" title="Iterates through the gates of a module.">GateIterator</a> for that purpose. 
</div>
</div><p>
<a class="anchor" name="604d651ab2c45c51c11712ac1e86c9ce"></a><!-- doxytag: member="cModule::gate" ref="604d651ab2c45c51c11712ac1e86c9ce" args="(int id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcGate.html">cGate</a>* cModule::gate           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a gate by its ID. 
<p>
It throws an error for invalid (or stale) IDs.<p>
Note: as of OMNeT++ 4.0, gate IDs are no longer small integers and are not suitable for enumerating all gates of a module. Use <a class="el" href="classcModule_1_1GateIterator.html" title="Iterates through the gates of a module.">GateIterator</a> for that purpose. 
</div>
</div><p>
<a class="anchor" name="3beb4e7ef94e2b8cff4a5b90fcb7c743"></a><!-- doxytag: member="cModule::deleteGate" ref="3beb4e7ef94e2b8cff4a5b90fcb7c743" args="(const char *gatename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::deleteGate           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes a gate, gate pair, or gate vector. 
<p>
Note: individual gates in a gate vector and one side of an inout gate (i.e. "foo$i") cannot be deleted. IDs of deleted gates will not be reused later. 
</div>
</div><p>
<a class="anchor" name="97e1b240b3f4c566436180a6471a850b"></a><!-- doxytag: member="cModule::getGateNames" ref="97e1b240b3f4c566436180a6471a850b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;const char *&gt; cModule::getGateNames           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the names of the module's gates. 
<p>
For gate vectors and inout gates, only the base name is returned (without gate index, "[]" or the "$i"/"$o" suffix). Zero-size gate vectors will also be included.<p>
The strings in the returned array do not need to be deallocated and must not be modified.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcModule.html#fdbf2cebc7f52d6518c6f67819d1ec76" title="Returns the type of the gate (or gate vector) with the given name.">gateType()</a>, <a class="el" href="classcModule.html#4f373def6f1b151fea20a4b8e72de9f6" title="Returns whether the given gate is a gate vector.">isGateVector()</a>, <a class="el" href="classcModule.html#c63b0b9c805c5f335d274195f2fdb28c" title="Returns the size of the gate vector with the given name.">gateSize()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fdbf2cebc7f52d6518c6f67819d1ec76"></a><!-- doxytag: member="cModule::gateType" ref="fdbf2cebc7f52d6518c6f67819d1ec76" args="(const char *gatename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcGate.html#c548a8cc681cf0c39afb2b993fe6e09f">cGate::Type</a> cModule::gateType           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the type of the gate (or gate vector) with the given name. 
<p>
Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if there is no such gate or gate vector. 
</div>
</div><p>
<a class="anchor" name="4f373def6f1b151fea20a4b8e72de9f6"></a><!-- doxytag: member="cModule::isGateVector" ref="4f373def6f1b151fea20a4b8e72de9f6" args="(const char *gatename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::isGateVector           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the given gate is a gate vector. 
<p>
Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if there is no such gate or gate vector. 
</div>
</div><p>
<a class="anchor" name="c63b0b9c805c5f335d274195f2fdb28c"></a><!-- doxytag: member="cModule::gateSize" ref="c63b0b9c805c5f335d274195f2fdb28c" args="(const char *gatename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int cModule::gateSize           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the size of the gate vector with the given name. 
<p>
It returns 1 for non-vector gates, and 0 if the gate does not exist or the vector has size 0. (Zero-size vectors are represented by a single gate whose <a class="el" href="classcModule.html#d08955e71fd144469a04f0ea26c22766" title="Alias for getVectorSize().">size()</a> returns 0.) Gate names with the "$i" or "$o" suffix are also accepted. Throws an error if there is no such gate or gate vector.<p>
Note: The gate vector size can also be obtained by calling the <a class="el" href="classcGate.html#37b65df3aa9d178949882e0e7f03362f" title="Alias for getVectorSize().">cGate::size()</a> method of any gate object. 
</div>
</div><p>
<a class="anchor" name="4d11f590eb1770be0e418da02c68e785"></a><!-- doxytag: member="cModule::gateBaseId" ref="4d11f590eb1770be0e418da02c68e785" args="(const char *gatename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int cModule::gateBaseId           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For vector gates, it returns the ID of gate 0 in the vector, even if the gate size is currently zero. 
<p>
All gates in the vector can be accessed by ID = gateBaseId + index. For scalar gates, it returns the ID of the gate. If there is no such gate or gate vector, an error gets thrown.<p>
Note: Gate IDs are guaranteed to be stable, i.e. they do not change if the gate vector gets resized, or other gates get added/removed. 
</div>
</div><p>
<a class="anchor" name="bd0b3bd68688e456141f855b16a8f836"></a><!-- doxytag: member="cModule::checkInternalConnections" ref="bd0b3bd68688e456141f855b16a8f836" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cModule::checkInternalConnections           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For compound modules, it checks if all gates are connected inside the module (it returns <code>true</code> if they are OK); for simple modules, it returns <code>true</code>. 
<p>
This function is called during network setup. 
</div>
</div><p>
<a class="anchor" name="d59a57aa7f6b19ff0061cbd87917cb74"></a><!-- doxytag: member="cModule::getAncestorPar" ref="d59a57aa7f6b19ff0061cbd87917cb74" args="(const char *parname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcPar.html">cPar</a>&amp; cModule::getAncestorPar           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>parname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the parameter in the parent modules, up to the system module. 
<p>
If the parameter is not found, throws <a class="el" href="classcRuntimeError.html" title="Thrown when the simulation kernel or other components detect a runtime error.">cRuntimeError</a>. 
</div>
</div><p>
<a class="anchor" name="2479e23e50fd2286730892ef59cc784e"></a><!-- doxytag: member="cModule::callInitialize" ref="2479e23e50fd2286730892ef59cc784e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::callInitialize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interface for calling <a class="el" href="classcComponent.html#0532af98c1157359b60adcb09f3fefca" title="Single-stage initialization hook.">initialize()</a> from outside. 
<p>

<p>Implements <a class="el" href="classcComponent.html#b164f60f671d675a83247c109b679ea8">cComponent</a>.</p>

</div>
</div><p>
<a class="anchor" name="fa97027522d4296a3436a6bb5cd2fa6e"></a><!-- doxytag: member="cModule::callInitialize" ref="fa97027522d4296a3436a6bb5cd2fa6e" args="(int stage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cModule::callInitialize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stage</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interface for calling <a class="el" href="classcComponent.html#0532af98c1157359b60adcb09f3fefca" title="Single-stage initialization hook.">initialize()</a> from outside. 
<p>
It does a single stage of initialization, and returns <code>true</code> if more stages are required. 
<p>Implements <a class="el" href="classcComponent.html#375336cd9e73e0067e27ef8e9b47276b">cComponent</a>.</p>

</div>
</div><p>
<a class="anchor" name="200cedd49110c4b22018dd7ce669b073"></a><!-- doxytag: member="cModule::callFinish" ref="200cedd49110c4b22018dd7ce669b073" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::callFinish           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interface for calling <a class="el" href="classcComponent.html#85912f961df471a9795d4e8454d9f6b0" title="Finish hook.">finish()</a> from outside. 
<p>

<p>Implements <a class="el" href="classcComponent.html#6d81bdafdf5168081513b1c139e0970b">cComponent</a>.</p>

</div>
</div><p>
<a class="anchor" name="aaed82aec8392c256d984b7975384d0c"></a><!-- doxytag: member="cModule::scheduleStart" ref="aaed82aec8392c256d984b7975384d0c" args="(simtime_t t)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::scheduleStart           </td>
          <td>(</td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pure virtual function; it is redefined in both <a class="el" href="classcCompoundModule.html" title="Represents a compound module in the simulation.">cCompoundModule</a> and <a class="el" href="classcSimpleModule.html" title="Base class for all simple module classes.">cSimpleModule</a>. 
<p>
It creates a starting message for a dynamically created module (and recursively for its submodules). See the user manual for explanation how to use dynamically created modules. 
<p>Implemented in <a class="el" href="classcCompoundModule.html#ff87cb12d49f7498446545a4ee79085b">cCompoundModule</a>, and <a class="el" href="classcSimpleModule.html#da3fe83c75268f2cae40959d6b2dc64e">cSimpleModule</a>.</p>

</div>
</div><p>
<a class="anchor" name="a40e04f3a15395bfad553227c0a51866"></a><!-- doxytag: member="cModule::deleteModule" ref="a40e04f3a15395bfad553227c0a51866" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::deleteModule           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the module and recursively all its submodules. 
<p>
This method has to be used if a simple module wants to delete itself (<code>delete this</code> is not allowed.) 
<p>Reimplemented in <a class="el" href="classcSimpleModule.html#ed071be3b66c9a695b51bfebd19c5aa5">cSimpleModule</a>.</p>

</div>
</div><p>
<a class="anchor" name="f9e5fae012b14606d5e58cab261c91af"></a><!-- doxytag: member="cModule::changeParentTo" ref="f9e5fae012b14606d5e58cab261c91af" args="(cModule *mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cModule::changeParentTo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the module under a new parent module. 
<p>
This functionality may be useful for some (rare) mobility scenarios.<p>
This function could bypass several rules which are enforced when you build the model using NED, so you must observe the following:<p>
<ol type=1>
<li>you cannot insert the module under one of its own submodules. This is checked by this function.</li><li>gates of the module cannot be connected when you move it. If you moved a module which is connected to its parent module or to other submodules, you'd create connections that do not obey the module hierarchy, and this is not permitted. This rule is also enforced by the implementation of this function.</li><li>it is recommended that the module name be made unique among the submodules of its new parent.</li><li>be aware that if the module is part of a module vector, its <a class="el" href="classcModule.html#bc24e9322a19c30da173000110f26596" title="Returns true if this module is in a module vector.">isVector()</a>, <a class="el" href="classcModule.html#604e26394d77938a860eeb4452f25606" title="Returns the index of the module if it is in a module vector, otherwise 0.">getIndex()</a> and <a class="el" href="classcModule.html#d08955e71fd144469a04f0ea26c22766" title="Alias for getVectorSize().">size()</a> functions will continue to deliver the same info -- although other elements of the vector will not necessarily be present under the same parent module. </li></ol>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cmodule_8h-source.html">cmodule.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 3 14:40:28 2013 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
